
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>stingray.varenergyspectrum &#8212; stingray v0.3.dev426+g3e4bd5e</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">stingray v0.3.dev426+g3e4bd5e</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for stingray.varenergyspectrum</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">stingray.gti</span> <span class="kn">import</span> <span class="n">check_separate</span><span class="p">,</span> <span class="n">cross_two_gtis</span><span class="p">,</span> <span class="n">create_gti_mask</span>
<span class="kn">from</span> <span class="nn">stingray.lightcurve</span> <span class="kn">import</span> <span class="n">Lightcurve</span>
<span class="kn">from</span> <span class="nn">stingray.utils</span> <span class="kn">import</span> <span class="n">assign_value_if_none</span><span class="p">,</span> <span class="n">simon</span><span class="p">,</span> <span class="n">excess_variance</span>
<span class="kn">from</span> <span class="nn">stingray.crossspectrum</span> <span class="kn">import</span> <span class="n">AveragedCrossspectrum</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">six</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;VarEnergySpectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;RmsEnergySpectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;LagEnergySpectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;ExcessVarianceSpectrum&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_decode_energy_specification</span><span class="p">(</span><span class="n">energy_spec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decode the energy specification tuple.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    energy_spec : iterable</span>
<span class="sd">        list containing the energy specification</span>
<span class="sd">        Must have the following structure:</span>
<span class="sd">            * energy_spec[0]: lower edge of (log) energy space</span>
<span class="sd">            * energy_spec[1]: upper edge of (log) energy space</span>
<span class="sd">            * energy_spec[2] +1 : energy bin edges (hence the +1)</span>
<span class="sd">            * {`lin` | `log`} flat deciding whether the energy space is linear</span>
<span class="sd">              or logarithmic</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    energies : numpy.ndarray</span>
<span class="sd">        An array of lower/upper bin edges for the energy array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _decode_energy_specification([0, 2, 2, &#39;lin&#39;])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">     ...</span>
<span class="sd">    ValueError: Energy specification must be a tuple</span>
<span class="sd">    &gt;&gt;&gt; a = _decode_energy_specification((0, 2, 2, &#39;lin&#39;))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, [0, 1, 2])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; a = _decode_energy_specification((1, 4, 2, &#39;log&#39;))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, [1, 2, 4])</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energy_spec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Energy specification must be a tuple&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">energy_spec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lin&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect energy specification&quot;</span><span class="p">)</span>

    <span class="n">log_distr</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">energy_spec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">log_distr</span><span class="p">:</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">energy_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">energy_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                               <span class="n">energy_spec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">energy_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">energy_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">energy_spec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">energies</span>


<div class="viewcode-block" id="VarEnergySpectrum"><a class="viewcode-back" href="../../api.html#stingray.varenergyspectrum.VarEnergySpectrum">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">VarEnergySpectrum</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for variability-energy spectrum.</span>

<span class="sd">    This class is only a base for the various variability spectra, and it&#39;s</span>
<span class="sd">    not to be instantiated by itself.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events : :class:`stingray.events.EventList` object</span>
<span class="sd">        event list</span>

<span class="sd">    freq_interval : ``[f0, f1]``, floats</span>
<span class="sd">        the frequency range over which calculating the variability quantity</span>

<span class="sd">    energy_spec : list or tuple ``(emin, emax, N, type)``</span>
<span class="sd">        if a ``list`` is specified, this is interpreted as a list of bin edges;</span>
<span class="sd">        if a ``tuple`` is provided, this will encode the minimum and maximum</span>
<span class="sd">        energies, the number of intervals, and ``lin`` or ``log``.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    ref_band : ``[emin, emax``], floats; default ``None``</span>
<span class="sd">        minimum and maximum energy of the reference band. If ``None``, the</span>
<span class="sd">        full band is used.</span>

<span class="sd">    use_pi : bool, default ``False``</span>
<span class="sd">        Use channel instead of energy</span>

<span class="sd">    events2 : :class:`stingray.events.EventList` object</span>
<span class="sd">        event list for the second channel, if not the same. Useful if the</span>
<span class="sd">        reference band has to be taken from another detector.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    events1 : array-like</span>
<span class="sd">        list of events used to produce the spectrum</span>

<span class="sd">    events2 : array-like</span>
<span class="sd">        if the spectrum requires it, second list of events</span>

<span class="sd">    freq_interval : array-like</span>
<span class="sd">        interval of frequencies used to calculate the spectrum</span>

<span class="sd">    energy_intervals : ``[[e00, e01], [e10, e11], ...]``</span>
<span class="sd">        energy intervals used for the spectrum</span>

<span class="sd">    spectrum : array-like</span>
<span class="sd">        the spectral values, corresponding to each energy interval</span>

<span class="sd">    spectrum_error : array-like</span>
<span class="sd">        the error bars corresponding to spectrum</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">freq_interval</span><span class="p">,</span> <span class="n">energy_spec</span><span class="p">,</span> <span class="n">ref_band</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">bin_time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_pi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">segment_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">events2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">events1</span> <span class="o">=</span> <span class="n">events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events2</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">events2</span><span class="p">,</span> <span class="n">events</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_interval</span> <span class="o">=</span> <span class="n">freq_interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_pi</span> <span class="o">=</span> <span class="n">use_pi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_time</span> <span class="o">=</span> <span class="n">bin_time</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energy_spec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="n">_decode_energy_specification</span><span class="p">(</span><span class="n">energy_spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">energy_spec</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">energy_intervals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">energies</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">ref_band</span><span class="p">,</span>
                                                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_band</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_band</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">segment_size</span> <span class="o">=</span> <span class="n">segment_size</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">simon</span><span class="p">(</span><span class="s2">&quot;There are no events in your event list!&quot;</span> <span class="o">+</span>
                  <span class="s2">&quot;Can&#39;t make a spectrum!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_error</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectrum_function</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_decide_ref_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_band</span><span class="p">,</span> <span class="n">ref_band</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures that the ``channel_band`` (i.e. the band of interest) is</span>
<span class="sd">        not contained within the ``ref_band`` (i.e. the reference band)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        channel_band : iterable of type ``[elow, ehigh]``</span>
<span class="sd">            The lower/upper limits of the energies to be contained in the band</span>
<span class="sd">            of interest</span>

<span class="sd">        ref_band : iterable</span>
<span class="sd">            The lower/upper limits of the energies in the reference band</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ref_intervals : iterable</span>
<span class="sd">            The channels that are both in the reference band in not in the</span>
<span class="sd">            bands of interest</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">channel_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">channel_band</span><span class="p">)</span>
        <span class="n">ref_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_band</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_band</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ref_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">ref_band</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">check_separate</span><span class="p">(</span><span class="n">ref_band</span><span class="p">,</span> <span class="p">[</span><span class="n">channel_band</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_band</span><span class="p">)</span>
        <span class="n">not_channel_band</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel_band</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">channel_band</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ref_band</span><span class="p">),</span>
                                                      <span class="n">channel_band</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]]</span>

        <span class="k">return</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="n">ref_band</span><span class="p">,</span> <span class="n">not_channel_band</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_lightcurves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_band</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct light curves from event data, for each band of interest.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        channel_band : iterable of type ``[elow, ehigh]``</span>
<span class="sd">            The lower/upper limits of the energies to be contained in the band</span>
<span class="sd">            of interest</span>

<span class="sd">        tstart : float, optional, default ``None``</span>
<span class="sd">            A common start time (if start of observation is different from</span>
<span class="sd">            the first recorded event)</span>

<span class="sd">        tstop : float, optional, default ``None``</span>
<span class="sd">            A common stop time (if start of observation is different from</span>
<span class="sd">            the first recorded event)</span>

<span class="sd">        exclude : bool, optional, default ``True``</span>
<span class="sd">            if ``True``, exclude the band of interest from the reference band</span>

<span class="sd">        only_base : bool, optional, default ``False``</span>
<span class="sd">            if ``True``, only return the light curve of the channel of interest, not</span>
<span class="sd">            that of the reference band</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        base_lc : :class:`Lightcurve` object</span>
<span class="sd">            The light curve of the channels of interest</span>

<span class="sd">        ref_lc : :class:`Lightcurve` object (only returned if ``only_base`` is ``False``)</span>
<span class="sd">            The reference light curve for comparison with ``base_lc``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pi</span><span class="p">:</span>
            <span class="n">energies1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events1</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">energies2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events2</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energies2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events2</span><span class="o">.</span><span class="n">energy</span>
            <span class="n">energies1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events1</span><span class="o">.</span><span class="n">energy</span>

        <span class="n">gti</span> <span class="o">=</span> <span class="n">cross_two_gtis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events1</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">events2</span><span class="o">.</span><span class="n">gti</span><span class="p">)</span>

        <span class="n">tstart</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">gti</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">tstop</span> <span class="o">=</span> <span class="n">assign_value_if_none</span><span class="p">(</span><span class="n">tstop</span><span class="p">,</span> <span class="n">gti</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">energies1</span> <span class="o">&gt;=</span> <span class="n">channel_band</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">energies1</span> <span class="o">&lt;</span> <span class="n">channel_band</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">base_lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="o">.</span><span class="n">make_lightcurve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events1</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">good</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">bin_time</span><span class="p">,</span>
                                             <span class="n">tstart</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span>
                                             <span class="n">tseg</span><span class="o">=</span><span class="n">tstop</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">,</span>
                                             <span class="n">gti</span><span class="o">=</span><span class="n">gti</span><span class="p">,</span>
                                             <span class="n">mjdref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">events1</span><span class="o">.</span><span class="n">mjdref</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">only_base</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base_lc</span>

        <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
            <span class="n">ref_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decide_ref_intervals</span><span class="p">(</span><span class="n">channel_band</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">ref_band</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_band</span>

        <span class="n">ref_lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="p">(</span><span class="n">base_lc</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">base_lc</span><span class="o">.</span><span class="n">counts</span><span class="p">),</span>
                            <span class="n">gti</span><span class="o">=</span><span class="n">base_lc</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span> <span class="n">mjdref</span><span class="o">=</span><span class="n">base_lc</span><span class="o">.</span><span class="n">mjdref</span><span class="p">,</span>
                            <span class="n">err_dist</span><span class="o">=</span><span class="s1">&#39;gauss&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ref_intervals</span><span class="p">:</span>
            <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">energies2</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">energies2</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">new_lc</span> <span class="o">=</span> <span class="n">Lightcurve</span><span class="o">.</span><span class="n">make_lightcurve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events2</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">good</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">bin_time</span><span class="p">,</span>
                                                <span class="n">tstart</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span>
                                                <span class="n">tseg</span><span class="o">=</span><span class="n">tstop</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">,</span>
                                                <span class="n">gti</span><span class="o">=</span><span class="n">base_lc</span><span class="o">.</span><span class="n">gti</span><span class="p">,</span>
                                                <span class="n">mjdref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">events2</span><span class="o">.</span><span class="n">mjdref</span><span class="p">)</span>
            <span class="n">ref_lc</span> <span class="o">=</span> <span class="n">ref_lc</span> <span class="o">+</span> <span class="n">new_lc</span>

        <span class="n">ref_lc</span><span class="o">.</span><span class="n">err_dist</span> <span class="o">=</span> <span class="n">base_lc</span><span class="o">.</span><span class="n">err_dist</span>
        <span class="k">return</span> <span class="n">base_lc</span><span class="p">,</span> <span class="n">ref_lc</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_spectrum_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="RmsEnergySpectrum"><a class="viewcode-back" href="../../api.html#stingray.varenergyspectrum.RmsEnergySpectrum">[docs]</a><span class="k">class</span> <span class="nc">RmsEnergySpectrum</span><span class="p">(</span><span class="n">VarEnergySpectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the rms-Energy spectrum.</span>

<span class="sd">    For each energy interval, calculate the power density spectrum in</span>
<span class="sd">    fractional r.m.s. normalization. If ``events2`` is specified, the cospectrum</span>
<span class="sd">    is used instead of the PDS.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events : :class:`stingray.events.EventList` object</span>
<span class="sd">        event list</span>

<span class="sd">    freq_interval : ``[f0, f1]``, list of float</span>
<span class="sd">        the frequency range over which calculating the variability quantity</span>

<span class="sd">    energy_spec : list or tuple ``(emin, emax, N, type)``</span>
<span class="sd">        if a ``list`` is specified, this is interpreted as a list of bin edges;</span>
<span class="sd">        if a ``tuple`` is provided, this will encode the minimum and maximum</span>
<span class="sd">        energies, the number of intervals, and ``lin`` or ``log``.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    ref_band : ``[emin, emax]``, float; default ``None``</span>
<span class="sd">        minimum and maximum energy of the reference band. If ``None``, the</span>
<span class="sd">        full band is used.</span>

<span class="sd">    use_pi : bool, default ``False``</span>
<span class="sd">        Use channel instead of energy</span>

<span class="sd">    events2 : :class:`stingray.events.EventList` object</span>
<span class="sd">        event list for the second channel, if not the same. Useful if the</span>
<span class="sd">        reference band has to be taken from another detector.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    events1 : array-like</span>
<span class="sd">        list of events used to produce the spectrum</span>

<span class="sd">    events2 : array-like</span>
<span class="sd">        if the spectrum requires it, second list of events</span>

<span class="sd">    freq_interval : array-like</span>
<span class="sd">        interval of frequencies used to calculate the spectrum</span>

<span class="sd">    energy_intervals : ``[[e00, e01], [e10, e11], ...]``</span>
<span class="sd">        energy intervals used for the spectrum</span>

<span class="sd">    spectrum : array-like</span>
<span class="sd">        the spectral values, corresponding to each energy interval</span>

<span class="sd">    spectrum_error : array-like</span>
<span class="sd">        the errorbars corresponding to spectrum</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_spectrum_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">rms_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_intervals</span><span class="p">))</span>
        <span class="n">rms_spec_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rms_spec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_intervals</span><span class="p">):</span>
            <span class="n">base_lc</span><span class="p">,</span> <span class="n">ref_lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_lightcurves</span><span class="p">(</span><span class="n">eint</span><span class="p">,</span>
                                                          <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">xspect</span> <span class="o">=</span> <span class="n">AveragedCrossspectrum</span><span class="p">(</span><span class="n">base_lc</span><span class="p">,</span> <span class="n">ref_lc</span><span class="p">,</span>
                                               <span class="n">segment_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">segment_size</span><span class="p">,</span>
                                               <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;frac&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Avoid &quot;Mean count rate is &lt;= 0. Something went wrong&quot; assertion.</span>
                <span class="n">simon</span><span class="p">(</span><span class="s2">&quot;AssertionError: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">xspect</span><span class="o">.</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">xspect</span><span class="o">.</span><span class="n">freq</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">rms_spec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xspect</span><span class="o">.</span><span class="n">power</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">*</span> <span class="n">xspect</span><span class="o">.</span><span class="n">df</span><span class="p">))</span>

                <span class="c1"># Root squared sum of errors of the spectrum</span>
                <span class="n">root_sq_err_sum</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xspect</span><span class="o">.</span><span class="n">power_err</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="o">*</span> <span class="n">xspect</span><span class="o">.</span><span class="n">df</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="c1"># But the rms is the squared root. So,</span>
                <span class="c1"># Error propagation</span>
                <span class="n">rms_spec_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">rms_spec</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">root_sq_err_sum</span>

        <span class="k">return</span> <span class="n">rms_spec</span><span class="p">,</span> <span class="n">rms_spec_err</span></div>


<div class="viewcode-block" id="LagEnergySpectrum"><a class="viewcode-back" href="../../api.html#stingray.varenergyspectrum.LagEnergySpectrum">[docs]</a><span class="k">class</span> <span class="nc">LagEnergySpectrum</span><span class="p">(</span><span class="n">VarEnergySpectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the lag-energy spectrum.</span>

<span class="sd">    For each energy interval, calculate the mean lag in the specified frequency</span>
<span class="sd">    range. If ``events2`` is specified, the reference band is taken from the second</span>
<span class="sd">    event list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events : :class:`stingray.events.EventList` object</span>
<span class="sd">        event list</span>

<span class="sd">    freq_interval : ``[f0, f1]``, list of float</span>
<span class="sd">        the frequency range over which calculating the variability quantity</span>

<span class="sd">    energy_spec : list or tuple ``(emin, emax, N, type)``</span>
<span class="sd">        if a list is specified, this is interpreted as a list of bin edges;</span>
<span class="sd">        if a tuple is provided, this will encode the minimum and maximum</span>
<span class="sd">        energies, the number of intervals, and ``lin`` or ``log``.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    ref_band : ``[emin, emax]``, float; default ``None``</span>
<span class="sd">        minimum and maximum energy of the reference band. If ``None``, the</span>
<span class="sd">        full band is used.</span>

<span class="sd">    use_pi : bool, default ``False``</span>
<span class="sd">        Use channel instead of energy</span>

<span class="sd">    events2 : :class:`stingray.events.EventList` object</span>
<span class="sd">        event list for the second channel, if not the same. Useful if the</span>
<span class="sd">        reference band has to be taken from another detector.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    events1 : array-like</span>
<span class="sd">        list of events used to produce the spectrum</span>

<span class="sd">    events2 : array-like</span>
<span class="sd">        if the spectrum requires it, second list of events</span>

<span class="sd">    freq_interval : array-like</span>
<span class="sd">        interval of frequencies used to calculate the spectrum</span>

<span class="sd">    energy_intervals : ``[[e00, e01], [e10, e11], ...]``</span>
<span class="sd">        energy intervals used for the spectrum</span>

<span class="sd">    spectrum : array-like</span>
<span class="sd">        the spectral values, corresponding to each energy interval</span>

<span class="sd">    spectrum_error : array-like</span>
<span class="sd">        the errorbars corresponding to spectrum</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_spectrum_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">lag_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_intervals</span><span class="p">))</span>
        <span class="n">lag_spec_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">lag_spec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_intervals</span><span class="p">):</span>
            <span class="n">base_lc</span><span class="p">,</span> <span class="n">ref_lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_lightcurves</span><span class="p">(</span><span class="n">eint</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">xspect</span> <span class="o">=</span> <span class="n">AveragedCrossspectrum</span><span class="p">(</span><span class="n">base_lc</span><span class="p">,</span> <span class="n">ref_lc</span><span class="p">,</span>
                                               <span class="n">segment_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">segment_size</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Avoid assertions in AveragedCrossspectrum.</span>
                <span class="n">simon</span><span class="p">(</span><span class="s2">&quot;AssertionError: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">xspect</span><span class="o">.</span><span class="n">freq</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> \
                       <span class="p">(</span><span class="n">xspect</span><span class="o">.</span><span class="n">freq</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">lag</span><span class="p">,</span> <span class="n">lag_err</span> <span class="o">=</span> <span class="n">xspect</span><span class="o">.</span><span class="n">time_lag</span><span class="p">()</span>
                <span class="n">good_lag</span><span class="p">,</span> <span class="n">good_lag_err</span> <span class="o">=</span> <span class="n">lag</span><span class="p">[</span><span class="n">good</span><span class="p">],</span> <span class="n">lag_err</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
                <span class="n">coh</span><span class="p">,</span> <span class="n">coh_err</span> <span class="o">=</span> <span class="n">xspect</span><span class="o">.</span><span class="n">coherence</span><span class="p">()</span>

                <span class="n">lag_spec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">good_lag</span><span class="p">)</span>
                <span class="n">coh_check</span> <span class="o">=</span> <span class="n">coh</span> <span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">xspect</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">coh_check</span><span class="p">[</span><span class="n">good</span><span class="p">]):</span>
                    <span class="n">simon</span><span class="p">(</span><span class="s2">&quot;Coherence is not ideal over the specified energy &quot;</span>
                          <span class="s2">&quot;range. Lag values and uncertainties might be &quot;</span>
                          <span class="s2">&quot;underestimated. See Epitropakis and Papadakis, &quot;</span>
                          <span class="s2">&quot;A\&amp;A 591, 1113, 2016&quot;</span><span class="p">)</span>

                <span class="c1"># Root squared sum of errors of the spectrum</span>
                <span class="c1"># Verified!</span>
                <span class="n">lag_spec_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_lag_err</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_lag</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">lag_spec</span><span class="p">,</span> <span class="n">lag_spec_err</span></div>


<div class="viewcode-block" id="ExcessVarianceSpectrum"><a class="viewcode-back" href="../../api.html#stingray.varenergyspectrum.ExcessVarianceSpectrum">[docs]</a><span class="k">class</span> <span class="nc">ExcessVarianceSpectrum</span><span class="p">(</span><span class="n">VarEnergySpectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Excess Variance spectrum.</span>

<span class="sd">    For each energy interval, calculate the excess variance in the specified</span>
<span class="sd">    frequency range.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events : :class:`stingray.events.EventList` object</span>
<span class="sd">        event list</span>

<span class="sd">    freq_interval : ``[f0, f1]``, list of float</span>
<span class="sd">        the frequency range over which calculating the variability quantity</span>

<span class="sd">    energy_spec : list or tuple ``(emin, emax, N, type)``</span>
<span class="sd">        if a list is specified, this is interpreted as a list of bin edges;</span>
<span class="sd">        if a tuple is provided, this will encode the minimum and maximum</span>
<span class="sd">        energies, the number of intervals, and ``lin`` or ``log``.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    ref_band : ``[emin, emax]``, floats; default ``None``</span>
<span class="sd">        minimum and maximum energy of the reference band. If ``None``, the</span>
<span class="sd">        full band is used.</span>

<span class="sd">    use_pi : bool, default ``False``</span>
<span class="sd">        Use channel instead of energy</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    events1 : array-like</span>
<span class="sd">        list of events used to produce the spectrum</span>

<span class="sd">    freq_interval : array-like</span>
<span class="sd">        interval of frequencies used to calculate the spectrum</span>

<span class="sd">    energy_intervals : ``[[e00, e01], [e10, e11], ...]``</span>
<span class="sd">        energy intervals used for the spectrum</span>

<span class="sd">    spectrum : array-like</span>
<span class="sd">        the spectral values, corresponding to each energy interval</span>

<span class="sd">    spectrum_error : array-like</span>
<span class="sd">        the errorbars corresponding to spectrum</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">freq_interval</span><span class="p">,</span> <span class="n">energy_spec</span><span class="p">,</span>
                 <span class="n">bin_time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">use_pi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">segment_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">normalization</span><span class="o">=</span><span class="s1">&#39;fvar&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">normalization</span> <span class="o">=</span> <span class="n">normalization</span>
        <span class="n">accepted_normalizations</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fvar&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">normalization</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accepted_normalizations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The normalization of excess variance must be &#39;</span>
                             <span class="s1">&#39;one of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">accepted_normalizations</span><span class="p">))</span>

        <span class="n">VarEnergySpectrum</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">freq_interval</span><span class="p">,</span> <span class="n">energy_spec</span><span class="p">,</span>
                                   <span class="n">bin_time</span><span class="o">=</span><span class="n">bin_time</span><span class="p">,</span> <span class="n">use_pi</span><span class="o">=</span><span class="n">use_pi</span><span class="p">,</span>
                                   <span class="n">segment_size</span><span class="o">=</span><span class="n">segment_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_spectrum_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_intervals</span><span class="p">))</span>
        <span class="n">spec_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_intervals</span><span class="p">):</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_lightcurves</span><span class="p">(</span><span class="n">eint</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">only_base</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">spec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">spec_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">excess_variance</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">spec_err</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2021, Stingray Developers.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.5.3. &nbsp;
    Last built 06 Apr 2021. <br/>
  </p>
</footer>
  </body>
</html>