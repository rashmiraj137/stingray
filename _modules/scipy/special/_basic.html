
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.special._basic &#8212; stingray v0.3.dev426+g3e4bd5e</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">stingray v0.3.dev426+g3e4bd5e</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for scipy.special._basic</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Author:  Travis Oliphant, 2002</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">iscomplex</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span>
                   <span class="n">imag</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">place</span><span class="p">,</span> <span class="n">issubdtype</span><span class="p">,</span>
                   <span class="n">extract</span><span class="p">,</span> <span class="n">inexact</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">sinc</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_ufuncs</span> <span class="k">as</span> <span class="n">ufuncs</span>
<span class="kn">from</span> <span class="nn">._ufuncs</span> <span class="kn">import</span> <span class="p">(</span><span class="n">mathieu_a</span><span class="p">,</span> <span class="n">mathieu_b</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">jv</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span>
                      <span class="n">psi</span><span class="p">,</span> <span class="n">hankel1</span><span class="p">,</span> <span class="n">hankel2</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">kv</span><span class="p">,</span> <span class="n">ndtri</span><span class="p">,</span>
                      <span class="n">poch</span><span class="p">,</span> <span class="n">binom</span><span class="p">,</span> <span class="n">hyp0f1</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">specfun</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">orthogonal</span>
<span class="kn">from</span> <span class="nn">._comb</span> <span class="kn">import</span> <span class="n">_comb_int</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;ai_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assoc_laguerre&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bei_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;beip_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ber_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bernoulli&#39;</span><span class="p">,</span>
    <span class="s1">&#39;berp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bi_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;clpmn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;comb&#39;</span><span class="p">,</span>
    <span class="s1">&#39;digamma&#39;</span><span class="p">,</span>
    <span class="s1">&#39;diric&#39;</span><span class="p">,</span>
    <span class="s1">&#39;erf_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;euler&#39;</span><span class="p">,</span>
    <span class="s1">&#39;factorial&#39;</span><span class="p">,</span>
    <span class="s1">&#39;factorial2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;factorialk&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fresnel_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fresnelc_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fresnels_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gamma&#39;</span><span class="p">,</span>
    <span class="s1">&#39;h1vp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;h2vp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;hankel1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;hankel2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;hyp0f1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;iv&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ivp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jn_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jnjnp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jnp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jnyn_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jv&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jvp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kei_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;keip_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kelvin_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ker_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kerp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kv&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kvp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lmbda&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lpmn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lpn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lqmn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lqn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mathieu_a&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mathieu_b&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mathieu_even_coef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mathieu_odd_coef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ndtri&#39;</span><span class="p">,</span>
    <span class="s1">&#39;obl_cv_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbdn_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbdv_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbvv_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;perm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;polygamma&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pro_cv_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;psi&#39;</span><span class="p">,</span>
    <span class="s1">&#39;riccati_jn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;riccati_yn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sinc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;y0_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;y1_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;y1p_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yn_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ynp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yv&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yvp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;zeta&#39;</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="c1"># Raises an exception if float</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">err</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> must be a non-negative integer&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_name</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">return</span> <span class="n">n</span>


<span class="k">def</span> <span class="nf">diric</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Periodic sinc function, also called the Dirichlet function.</span>

<span class="sd">    The Dirichlet function is defined as::</span>

<span class="sd">        diric(x, n) = sin(x * n/2) / (n * sin(x / 2)),</span>

<span class="sd">    where `n` is a positive integer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Input data</span>
<span class="sd">    n : int</span>
<span class="sd">        Integer defining the periodicity.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diric : ndarray</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-8*np.pi, 8*np.pi, num=201)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 8));</span>
<span class="sd">    &gt;&gt;&gt; for idx, n in enumerate([2, 3, 4, 9]):</span>
<span class="sd">    ...     plt.subplot(2, 2, idx+1)</span>
<span class="sd">    ...     plt.plot(x, special.diric(x, n))</span>
<span class="sd">    ...     plt.title(&#39;diric, n={}&#39;.format(n))</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    The following example demonstrates that `diric` gives the magnitudes</span>
<span class="sd">    (modulo the sign and scaling) of the Fourier coefficients of a</span>
<span class="sd">    rectangular pulse.</span>

<span class="sd">    Suppress output of values that are effectively 0:</span>

<span class="sd">    &gt;&gt;&gt; np.set_printoptions(suppress=True)</span>

<span class="sd">    Create a signal `x` of length `m` with `k` ones:</span>

<span class="sd">    &gt;&gt;&gt; m = 8</span>
<span class="sd">    &gt;&gt;&gt; k = 3</span>
<span class="sd">    &gt;&gt;&gt; x = np.zeros(m)</span>
<span class="sd">    &gt;&gt;&gt; x[:k] = 1</span>

<span class="sd">    Use the FFT to compute the Fourier transform of `x`, and</span>
<span class="sd">    inspect the magnitudes of the coefficients:</span>

<span class="sd">    &gt;&gt;&gt; np.abs(np.fft.fft(x))</span>
<span class="sd">    array([ 3.        ,  2.41421356,  1.        ,  0.41421356,  1.        ,</span>
<span class="sd">            0.41421356,  1.        ,  2.41421356])</span>

<span class="sd">    Now find the same values (up to sign) using `diric`. We multiply</span>
<span class="sd">    by `k` to account for the different scaling conventions of</span>
<span class="sd">    `numpy.fft.fft` and `diric`:</span>

<span class="sd">    &gt;&gt;&gt; theta = np.linspace(0, 2*np.pi, m, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; k * special.diric(theta, k)</span>
<span class="sd">    array([ 3.        ,  2.41421356,  1.        , -0.41421356, -1.        ,</span>
<span class="sd">           -0.41421356,  1.        ,  2.41421356])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
        <span class="n">ytype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ytype</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ytype</span><span class="p">)</span>

    <span class="c1"># empirical minval for 32, 64 or 128 bit float computations</span>
    <span class="c1"># where sin(x/2) &lt; minval, result is fixed at +1 or -1</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">ytype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="mf">1e-18</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mf">1e-11</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">ytype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="mf">1e-15</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mf">1e-7</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="n">mask1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask1</span><span class="p">,</span> <span class="n">nan</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minval</span><span class="p">)</span>
    <span class="n">xsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">nsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">zsub</span> <span class="o">=</span> <span class="n">xsub</span> <span class="o">/</span> <span class="n">pi</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask2</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">zsub</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nsub</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask2</span><span class="p">)</span>
    <span class="n">xsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">nsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">dsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">nsub</span><span class="o">*</span><span class="n">xsub</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nsub</span><span class="o">*</span><span class="n">dsub</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">jnjnp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel functions Jn and Jn&#39;.</span>

<span class="sd">    Results are arranged in order of the magnitudes of the zeros.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number (&lt;=1200) of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zo[l-1] : ndarray</span>
<span class="sd">        Value of the lth zero of Jn(x) and Jn&#39;(x). Of length `nt`.</span>
<span class="sd">    n[l-1] : ndarray</span>
<span class="sd">        Order of the Jn(x) or Jn&#39;(x) associated with lth zero. Of length `nt`.</span>
<span class="sd">    m[l-1] : ndarray</span>
<span class="sd">        Serial number of the zeros of Jn(x) or Jn&#39;(x) associated</span>
<span class="sd">        with lth zero. Of length `nt`.</span>
<span class="sd">    t[l-1] : ndarray</span>
<span class="sd">        0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn&#39;(x). Of</span>
<span class="sd">        length `nt`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jn_zeros, jnp_zeros : to get separated arrays of zeros.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1200</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number must be integer &lt;= 1200.&quot;</span><span class="p">)</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">zo</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">jdzo</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zo</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">[:</span><span class="n">nt</span><span class="p">],</span> <span class="n">m</span><span class="p">[:</span><span class="n">nt</span><span class="p">],</span> <span class="n">t</span><span class="p">[:</span><span class="n">nt</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel functions Jn(x), Jn&#39;(x), Yn(x), and Yn&#39;(x).</span>

<span class="sd">    Returns 4 arrays of length `nt`, corresponding to the first `nt`</span>
<span class="sd">    zeros of Jn(x), Jn&#39;(x), Yn(x), and Yn&#39;(x), respectively. The zeros</span>
<span class="sd">    are returned in ascending order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of the Bessel functions</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number (&lt;=1200) of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Jn : ndarray</span>
<span class="sd">        First `nt` zeros of Jn</span>
<span class="sd">    Jnp : ndarray</span>
<span class="sd">        First `nt` zeros of Jn&#39;</span>
<span class="sd">    Yn : ndarray</span>
<span class="sd">        First `nt` zeros of Yn</span>
<span class="sd">    Ynp : ndarray</span>
<span class="sd">        First `nt` zeros of Yn&#39;</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jn_zeros, jnp_zeros, yn_zeros, ynp_zeros</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt &gt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">jyzo</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel functions Jn.</span>

<span class="sd">    Compute `nt` zeros of the Bessel functions :math:`J_n(x)` on the</span>
<span class="sd">    interval :math:`(0, \infty)`. The zeros are returned in ascending</span>
<span class="sd">    order. Note that this interval excludes the zero at :math:`x = 0`</span>
<span class="sd">    that exists for :math:`n &gt; 0`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `n` zeros of the Bessel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jv</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import scipy.special as sc</span>

<span class="sd">    We can check that we are getting approximations of the zeros by</span>
<span class="sd">    evaluating them with `jv`.</span>

<span class="sd">    &gt;&gt;&gt; n = 1</span>
<span class="sd">    &gt;&gt;&gt; x = sc.jn_zeros(n, 3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 3.83170597,  7.01558667, 10.17346814])</span>
<span class="sd">    &gt;&gt;&gt; sc.jv(n, x)</span>
<span class="sd">    array([-0.00000000e+00,  1.72975330e-16,  2.89157291e-16])</span>

<span class="sd">    Note that the zero at ``x = 0`` for ``n &gt; 0`` is not included.</span>

<span class="sd">    &gt;&gt;&gt; sc.jv(1, 0)</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">jnp_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function derivatives Jn&#39;.</span>

<span class="sd">    Compute `nt` zeros of the functions :math:`J_n&#39;(x)` on the</span>
<span class="sd">    interval :math:`(0, \infty)`. The zeros are returned in ascending</span>
<span class="sd">    order. Note that this interval excludes the zero at :math:`x = 0`</span>
<span class="sd">    that exists for :math:`n &gt; 1`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `n` zeros of the Bessel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jvp, jv</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import scipy.special as sc</span>

<span class="sd">    We can check that we are getting approximations of the zeros by</span>
<span class="sd">    evaluating them with `jvp`.</span>

<span class="sd">    &gt;&gt;&gt; n = 2</span>
<span class="sd">    &gt;&gt;&gt; x = sc.jnp_zeros(n, 3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([3.05423693, 6.70613319, 9.96946782])</span>
<span class="sd">    &gt;&gt;&gt; sc.jvp(n, x)</span>
<span class="sd">    array([ 2.77555756e-17,  2.08166817e-16, -3.01841885e-16])</span>

<span class="sd">    Note that the zero at ``x = 0`` for ``n &gt; 1`` is not included.</span>

<span class="sd">    &gt;&gt;&gt; sc.jvp(n, 0)</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">yn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function Yn(x).</span>

<span class="sd">    Compute `nt` zeros of the functions :math:`Y_n(x)` on the interval</span>
<span class="sd">    :math:`(0, \infty)`. The zeros are returned in ascending order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `n` zeros of the Bessel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    yn, yv</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import scipy.special as sc</span>

<span class="sd">    We can check that we are getting approximations of the zeros by</span>
<span class="sd">    evaluating them with `yn`.</span>

<span class="sd">    &gt;&gt;&gt; n = 2</span>
<span class="sd">    &gt;&gt;&gt; x = sc.yn_zeros(n, 3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 3.38424177,  6.79380751, 10.02347798])</span>
<span class="sd">    &gt;&gt;&gt; sc.yn(n, x)</span>
<span class="sd">    array([-1.94289029e-16,  8.32667268e-17, -1.52655666e-16])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">ynp_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function derivatives Yn&#39;(x).</span>

<span class="sd">    Compute `nt` zeros of the functions :math:`Y_n&#39;(x)` on the</span>
<span class="sd">    interval :math:`(0, \infty)`. The zeros are returned in ascending</span>
<span class="sd">    order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    yvp</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import scipy.special as sc</span>

<span class="sd">    We can check that we are getting approximations of the zeros by</span>
<span class="sd">    evaluating them with `yvp`.</span>

<span class="sd">    &gt;&gt;&gt; n = 2</span>
<span class="sd">    &gt;&gt;&gt; x = sc.ynp_zeros(n, 3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 5.00258293,  8.3507247 , 11.57419547])</span>
<span class="sd">    &gt;&gt;&gt; sc.yvp(n, x)</span>
<span class="sd">    array([ 2.22044605e-16, -3.33066907e-16,  2.94902991e-16])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">y0_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel function Y0(z), and derivative at each zero.</span>

<span class="sd">    The derivatives are given by Y0&#39;(z0) = -Y1(z0) at each zero z0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z0n : ndarray</span>
<span class="sd">        Location of nth zero of Y0(z)</span>
<span class="sd">    y0pz0n : ndarray</span>
<span class="sd">        Value of derivative Y0&#39;(z0) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">y1_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel function Y1(z), and derivative at each zero.</span>

<span class="sd">    The derivatives are given by Y1&#39;(z1) = Y0(z1) at each zero z1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z1n : ndarray</span>
<span class="sd">        Location of nth zero of Y1(z)</span>
<span class="sd">    y1pz1n : ndarray</span>
<span class="sd">        Value of derivative Y1&#39;(z1) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">y1p_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel derivative Y1&#39;(z), and value at each zero.</span>

<span class="sd">    The values are given by Y1(z1) at each z1 where Y1&#39;(z1)=0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z1pn : ndarray</span>
<span class="sd">        Location of nth zero of Y1&#39;(z)</span>
<span class="sd">    y1z1pn : ndarray</span>
<span class="sd">        Value of derivative Y1(z1) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
    <span class="c1"># from AMS55.</span>
    <span class="c1"># L(v, z) = J(v, z), Y(v, z), H1(v, z), H2(v, z), phase = -1</span>
    <span class="c1"># L(v, z) = I(v, z) or exp(v*pi*i)K(v, z), phase = 1</span>
    <span class="c1"># For K, you can pull out the exp((v-k)*pi*i) into the caller</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">phase</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">i</span>   <span class="c1"># = choose(k, i)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">p</span><span class="o">*</span><span class="n">L</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute derivatives of Bessel functions of the first kind.</span>

<span class="sd">    Compute the nth derivative of the Bessel function `Jv` with</span>
<span class="sd">    respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate the derivative; can be real or</span>
<span class="sd">        complex.</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        Values of the derivative of the Bessel function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">jv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">yvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute derivatives of Bessel functions of the second kind.</span>

<span class="sd">    Compute the nth derivative of the Bessel function `Yv` with</span>
<span class="sd">    respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        nth derivative of the Bessel function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">yv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of real-order modified Bessel function Kv(z)</span>

<span class="sd">    Kv(z) is the modified Bessel function of the second kind.</span>
<span class="sd">    Derivative is calculated with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like of float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : array_like of complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of derivative.  Default is first derivative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The results</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate multiple values at order 5:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import kvp</span>
<span class="sd">    &gt;&gt;&gt; kvp(5, (1, 2, 3+5j))</span>
<span class="sd">    array([-1.84903536e+03+0.j        , -2.57735387e+01+0.j        ,</span>
<span class="sd">           -3.06627741e-02+0.08750845j])</span>


<span class="sd">    Calculate for a single value at multiple orders:</span>

<span class="sd">    &gt;&gt;&gt; kvp((4, 4.5, 5), 1)</span>
<span class="sd">    array([ -184.0309,  -568.9585, -1849.0354])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.29.5 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 6.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.29.E5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">kv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ivp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute derivatives of modified Bessel functions of the first kind.</span>

<span class="sd">    Compute the nth derivative of the modified Bessel function `Iv`</span>
<span class="sd">    with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Argument at which to evaluate the derivative; can be real or</span>
<span class="sd">        complex.</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        nth derivative of the modified Bessel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    iv</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.29.5 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 6.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.29.E5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">h1vp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of Hankel function H1v(z) with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Order of Hankel function</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Argument at which to evaluate the derivative. Can be real or</span>
<span class="sd">        complex.</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        Values of the derivative of the Hankel function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hankel1</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hankel1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">h2vp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nth derivative of Hankel function H2v(z) with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Order of Hankel function</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Argument at which to evaluate the derivative. Can be real or</span>
<span class="sd">        complex.</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        Values of the derivative of the Hankel function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hankel2</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hankel2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">riccati_jn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute Ricatti-Bessel function of the first kind and its derivative.</span>

<span class="sd">    The Ricatti-Bessel function of the first kind is defined as :math:`x</span>
<span class="sd">    j_n(x)`, where :math:`j_n` is the spherical Bessel function of the first</span>
<span class="sd">    kind of order :math:`n`.</span>

<span class="sd">    This function computes the value and first derivative of the</span>
<span class="sd">    Ricatti-Bessel function for all orders up to and including `n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of function to compute</span>
<span class="sd">    x : float</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jn : ndarray</span>
<span class="sd">        Value of j0(x), ..., jn(x)</span>
<span class="sd">    jnp : ndarray</span>
<span class="sd">        First derivative j0&#39;(x), ..., jn&#39;(x)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The computation is carried out via backward recurrence, using the</span>
<span class="sd">    relation DLMF 10.51.1 [2]_.</span>

<span class="sd">    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming</span>
<span class="sd">    Jin [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.51.E1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">rctj</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">jnp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">riccati_yn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute Ricatti-Bessel function of the second kind and its derivative.</span>

<span class="sd">    The Ricatti-Bessel function of the second kind is defined as :math:`x</span>
<span class="sd">    y_n(x)`, where :math:`y_n` is the spherical Bessel function of the second</span>
<span class="sd">    kind of order :math:`n`.</span>

<span class="sd">    This function computes the value and first derivative of the function for</span>
<span class="sd">    all orders up to and including `n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of function to compute</span>
<span class="sd">    x : float</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yn : ndarray</span>
<span class="sd">        Value of y0(x), ..., yn(x)</span>
<span class="sd">    ynp : ndarray</span>
<span class="sd">        First derivative y0&#39;(x), ..., yn&#39;(x)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The computation is carried out via ascending recurrence, using the</span>
<span class="sd">    relation DLMF 10.51.1 [2]_.</span>

<span class="sd">    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming</span>
<span class="sd">    Jin [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.51.E1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">rcty</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">jnp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">erf_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the first nt zero in the first quadrant, ordered by absolute value.</span>

<span class="sd">    Zeros in the other quadrants can be obtained by using the symmetries erf(-z) = erf(z) and</span>
<span class="sd">    erf(conj(z)) = conj(erf(z)).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        The number of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The locations of the zeros of erf : ndarray (complex)</span>
<span class="sd">        Complex values at which zeros of erf(z)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; special.erf_zeros(1)</span>
<span class="sd">    array([1.45061616+1.880943j])</span>

<span class="sd">    Check that erf is (close to) zero for the value returned by erf_zeros</span>

<span class="sd">    &gt;&gt;&gt; special.erf(special.erf_zeros(1))</span>
<span class="sd">    array([4.95159469e-14-1.16407394e-16j])</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cerzo</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnelc_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt complex zeros of cosine Fresnel integral C(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnels_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt complex zeros of sine Fresnel integral S(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnel_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="p">),</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">assoc_laguerre</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the generalized (associated) Laguerre polynomial of degree n and order k.</span>

<span class="sd">    The polynomial :math:`L^{(k)}_n(x)` is orthogonal over ``[0, inf)``,</span>
<span class="sd">    with weighting function ``exp(-x) * x**k`` with ``k &gt; -1``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `assoc_laguerre` is a simple wrapper around `eval_genlaguerre`, with</span>
<span class="sd">    reversed argument order ``(x, n, k=0.0) --&gt; (n, k, x)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">orthogonal</span><span class="o">.</span><span class="n">eval_genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="n">digamma</span> <span class="o">=</span> <span class="n">psi</span>


<span class="k">def</span> <span class="nf">polygamma</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Polygamma functions.</span>

<span class="sd">    Defined as :math:`\psi^{(n)}(x)` where :math:`\psi` is the</span>
<span class="sd">    `digamma` function. See [dlmf]_ for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : array_like</span>
<span class="sd">        The order of the derivative of the digamma function; must be</span>
<span class="sd">        integral</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Real valued input</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Function results</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    digamma</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [dlmf] NIST, Digital Library of Mathematical Functions,</span>
<span class="sd">        https://dlmf.nist.gov/5.15</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; x = [2, 3, 25.5]</span>
<span class="sd">    &gt;&gt;&gt; special.polygamma(1, x)</span>
<span class="sd">    array([ 0.64493407,  0.39493407,  0.03999467])</span>
<span class="sd">    &gt;&gt;&gt; special.polygamma(0, x) == special.psi(x)</span>
<span class="sd">    array([ True,  True,  True], dtype=bool)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">fac2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">zeta</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fac2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mathieu_even_coef</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fourier coefficients for even Mathieu and modified Mathieu functions.</span>

<span class="sd">    The Fourier series of the even solutions of the Mathieu differential</span>
<span class="sd">    equation are of the form</span>

<span class="sd">    .. math:: \mathrm{ce}_{2n}(z, q) = \sum_{k=0}^{\infty} A_{(2n)}^{(2k)} \cos 2kz</span>

<span class="sd">    .. math:: \mathrm{ce}_{2n+1}(z, q) = \sum_{k=0}^{\infty} A_{(2n+1)}^{(2k+1)} \cos (2k+1)z</span>

<span class="sd">    This function returns the coefficients :math:`A_{(2n)}^{(2k)}` for even</span>
<span class="sd">    input m=2n, and the coefficients :math:`A_{(2n+1)}^{(2k+1)}` for odd input</span>
<span class="sd">    m=2n+1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        Order of Mathieu functions.  Must be non-negative.</span>
<span class="sd">    q : float (&gt;=0)</span>
<span class="sd">        Parameter of Mathieu functions.  Must be non-negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ak : ndarray</span>
<span class="sd">        Even or odd Fourier coefficients, corresponding to even or odd m.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           https://dlmf.nist.gov/28.4#i</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m and q must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q &gt;=0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be an integer &gt;=0.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="mf">56.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mf">134.7</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mf">90.7</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">17.0</span> <span class="o">+</span> <span class="mf">3.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="o">.</span><span class="mi">126</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="o">.</span><span class="mi">0037</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="n">km</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qm</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">km</span> <span class="o">&gt;</span> <span class="mi">251</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning, too many predicted coefficients.&quot;</span><span class="p">)</span>
    <span class="n">kd</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">mathieu_a</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcoef</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fc</span><span class="p">[:</span><span class="n">km</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">mathieu_odd_coef</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fourier coefficients for even Mathieu and modified Mathieu functions.</span>

<span class="sd">    The Fourier series of the odd solutions of the Mathieu differential</span>
<span class="sd">    equation are of the form</span>

<span class="sd">    .. math:: \mathrm{se}_{2n+1}(z, q) = \sum_{k=0}^{\infty} B_{(2n+1)}^{(2k+1)} \sin (2k+1)z</span>

<span class="sd">    .. math:: \mathrm{se}_{2n+2}(z, q) = \sum_{k=0}^{\infty} B_{(2n+2)}^{(2k+2)} \sin (2k+2)z</span>

<span class="sd">    This function returns the coefficients :math:`B_{(2n+2)}^{(2k+2)}` for even</span>
<span class="sd">    input m=2n+2, and the coefficients :math:`B_{(2n+1)}^{(2k+1)}` for odd</span>
<span class="sd">    input m=2n+1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        Order of Mathieu functions.  Must be non-negative.</span>
<span class="sd">    q : float (&gt;=0)</span>
<span class="sd">        Parameter of Mathieu functions.  Must be non-negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Bk : ndarray</span>
<span class="sd">        Even or odd Fourier coefficients, corresponding to even or odd m.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m and q must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q &gt;=0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be an integer &gt; 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="mf">56.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mf">134.7</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mf">90.7</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">17.0</span> <span class="o">+</span> <span class="mf">3.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="o">.</span><span class="mi">126</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="o">.</span><span class="mi">0037</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="n">km</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qm</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">km</span> <span class="o">&gt;</span> <span class="mi">251</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning, too many predicted coefficients.&quot;</span><span class="p">)</span>
    <span class="n">kd</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">mathieu_b</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">fcoef</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fc</span><span class="p">[:</span><span class="n">km</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">lpmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sequence of associated Legendre functions of the first kind.</span>

<span class="sd">    Computes the associated Legendre function of the first kind of order m and</span>
<span class="sd">    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and</span>
<span class="sd">    ``Pmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    This function takes a real argument ``z``. For complex arguments ``z``</span>
<span class="sd">    use clpmn instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : float</span>
<span class="sd">        Input value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders 0..m and degrees 0..n</span>
<span class="sd">    Pmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders 0..m and degrees 0..n</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    clpmn: associated Legendre functions of the first kind for complex z</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the interval (-1, 1), Ferrer&#39;s function of the first kind is</span>
<span class="sd">    returned. The phase convention used for the intervals (1, inf)</span>
<span class="sd">    and (-inf, -1) is such that the result is always real.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           https://dlmf.nist.gov/14.3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be &lt;= n.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be real. Use clpmn instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Ferrer function; DLMF 14.9.3</span>
                <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                               <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">mf</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Match to clpmn; DLMF 14.9.13</span>
                <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lpmn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">fixarr</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span> <span class="o">*</span> <span class="n">fixarr</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">pd</span>


<span class="k">def</span> <span class="nf">clpmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Associated Legendre function of the first kind for complex arguments.</span>

<span class="sd">    Computes the associated Legendre function of the first kind of order m and</span>
<span class="sd">    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and</span>
<span class="sd">    ``Pmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : float or complex</span>
<span class="sd">        Input value.</span>
<span class="sd">    type : int, optional</span>
<span class="sd">       takes values 2 or 3</span>
<span class="sd">       2: cut on the real axis ``|x| &gt; 1``</span>
<span class="sd">       3: cut on the real axis ``-1 &lt; x &lt; 1`` (default)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders ``0..m`` and degrees ``0..n``</span>
<span class="sd">    Pmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders ``0..m`` and degrees ``0..n``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lpmn: associated Legendre functions of the first kind for real z</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default, i.e. for ``type=3``, phase conventions are chosen according</span>
<span class="sd">    to [1]_ such that the function is analytic. The cut lies on the interval</span>
<span class="sd">    (-1, 1). Approaching the cut from above or below in general yields a phase</span>
<span class="sd">    factor with respect to Ferrer&#39;s function of the first kind</span>
<span class="sd">    (cf. `lpmn`).</span>

<span class="sd">    For ``type=2`` a cut at ``|x| &gt; 1`` is chosen. Approaching the real values</span>
<span class="sd">    on the interval (-1, 1) in the complex plane yields Ferrer&#39;s function</span>
<span class="sd">    of the first kind.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           https://dlmf.nist.gov/14.21</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be &lt;= n.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">type</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;type must be either 2 or 3.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                               <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">mf</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">clpmn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">type</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">fixarr</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span> <span class="o">*</span> <span class="n">fixarr</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">pd</span>


<span class="k">def</span> <span class="nf">lqmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sequence of associated Legendre functions of the second kind.</span>

<span class="sd">    Computes the associated Legendre function of the second kind of order m and</span>
<span class="sd">    degree n, ``Qmn(z)`` = :math:`Q_n^m(z)`, and its derivative, ``Qmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Qmn(z)`` and</span>
<span class="sd">    ``Qmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Input value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Qmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders 0..m and degrees 0..n</span>
<span class="sd">    Qmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders 0..m and degrees 0..n</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Ensure neither m nor n == 0</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">clqmn</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lqmn</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q</span><span class="p">[:(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">qd</span><span class="p">[:(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">bernoulli</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bernoulli numbers B0..Bn (inclusive).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">bernob</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n1</span><span class="p">))[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">euler</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Euler numbers E(0), E(1), ..., E(n).</span>

<span class="sd">    The Euler numbers [1]_ are also known as the secant numbers.</span>

<span class="sd">    Because ``euler(n)`` returns floating point values, it does not give</span>
<span class="sd">    exact values for large `n`.  The first inexact value is E(22).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        The highest index of the Euler number to be returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        The Euler numbers [E(0), E(1), ..., E(n)].</span>
<span class="sd">        The odd Euler numbers, which are all zero, are included.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Sequence A122045, The On-Line Encyclopedia of Integer Sequences,</span>
<span class="sd">           https://oeis.org/A122045</span>
<span class="sd">    .. [2] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import euler</span>
<span class="sd">    &gt;&gt;&gt; euler(6)</span>
<span class="sd">    array([  1.,   0.,  -1.,   0.,   5.,   0., -61.])</span>

<span class="sd">    &gt;&gt;&gt; euler(13).astype(np.int64)</span>
<span class="sd">    array([      1,       0,      -1,       0,       5,       0,     -61,</span>
<span class="sd">                 0,    1385,       0,  -50521,       0, 2702765,       0])</span>

<span class="sd">    &gt;&gt;&gt; euler(22)[-1]  # Exact value of E(22) is -69348874393137901.</span>
<span class="sd">    -69348874393137976.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">eulerb</span><span class="p">(</span><span class="n">n1</span><span class="p">)[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">lpn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Legendre function of the first kind.</span>

<span class="sd">    Compute sequence of Legendre functions of the first kind (polynomials),</span>
<span class="sd">    Pn(z) and derivatives for all degrees from 0 to n (inclusive).</span>

<span class="sd">    See also special.legendre for polynomial class.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">pn</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">clpn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pn</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lpn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">pd</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">lqn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Legendre function of the second kind.</span>

<span class="sd">    Compute sequence of Legendre functions of the second kind, Qn(z) and</span>
<span class="sd">    derivatives for all degrees from 0 to n (inclusive).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">qn</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">clqn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qn</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lqnb</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">qd</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">ai_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `nt` zeros and values of the Airy function Ai and its derivative.</span>

<span class="sd">    Computes the first `nt` zeros, `a`, of the Airy function Ai(x);</span>
<span class="sd">    first `nt` zeros, `ap`, of the derivative of the Airy function Ai&#39;(x);</span>
<span class="sd">    the corresponding values Ai(a&#39;);</span>
<span class="sd">    and the corresponding values Ai&#39;(a).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        First `nt` zeros of Ai(x)</span>
<span class="sd">    ap : ndarray</span>
<span class="sd">        First `nt` zeros of Ai&#39;(x)</span>
<span class="sd">    ai : ndarray</span>
<span class="sd">        Values of Ai(x) evaluated at first `nt` zeros of Ai&#39;(x)</span>
<span class="sd">    aip : ndarray</span>
<span class="sd">        Values of Ai&#39;(x) evaluated at first `nt` zeros of Ai(x)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; a, ap, ai, aip = special.ai_zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([-2.33810741, -4.08794944, -5.52055983])</span>
<span class="sd">    &gt;&gt;&gt; ap</span>
<span class="sd">    array([-1.01879297, -3.24819758, -4.82009921])</span>
<span class="sd">    &gt;&gt;&gt; ai</span>
<span class="sd">    array([ 0.53565666, -0.41901548,  0.38040647])</span>
<span class="sd">    &gt;&gt;&gt; aip</span>
<span class="sd">    array([ 0.70121082, -0.80311137,  0.86520403])</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be a positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">airyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bi_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `nt` zeros and values of the Airy function Bi and its derivative.</span>

<span class="sd">    Computes the first `nt` zeros, b, of the Airy function Bi(x);</span>
<span class="sd">    first `nt` zeros, b&#39;, of the derivative of the Airy function Bi&#39;(x);</span>
<span class="sd">    the corresponding values Bi(b&#39;);</span>
<span class="sd">    and the corresponding values Bi&#39;(b).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        First `nt` zeros of Bi(x)</span>
<span class="sd">    bp : ndarray</span>
<span class="sd">        First `nt` zeros of Bi&#39;(x)</span>
<span class="sd">    bi : ndarray</span>
<span class="sd">        Values of Bi(x) evaluated at first `nt` zeros of Bi&#39;(x)</span>
<span class="sd">    bip : ndarray</span>
<span class="sd">        Values of Bi&#39;(x) evaluated at first `nt` zeros of Bi(x)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; b, bp, bi, bip = special.bi_zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([-1.17371322, -3.2710933 , -4.83073784])</span>
<span class="sd">    &gt;&gt;&gt; bp</span>
<span class="sd">    array([-2.29443968, -4.07315509, -5.51239573])</span>
<span class="sd">    &gt;&gt;&gt; bi</span>
<span class="sd">    array([-0.45494438,  0.39652284, -0.36796916])</span>
<span class="sd">    &gt;&gt;&gt; bip</span>
<span class="sd">    array([ 0.60195789, -0.76031014,  0.83699101])</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be a positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">airyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lmbda</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Jahnke-Emden Lambda function, Lambdav(x).</span>

<span class="sd">    This function is defined as [2]_,</span>

<span class="sd">    .. math:: \Lambda_v(x) = \Gamma(v+1) \frac{J_v(x)}{(x/2)^v},</span>

<span class="sd">    where :math:`\Gamma` is the gamma function and :math:`J_v` is the</span>
<span class="sd">    Bessel function of the first kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the Lambda function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vl : ndarray</span>
<span class="sd">        Values of Lambda_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dl : ndarray</span>
<span class="sd">        Derivatives Lambda_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] Jahnke, E. and Emde, F. &quot;Tables of Functions with Formulae and</span>
<span class="sd">           Curves&quot; (4th ed.), Dover, 1945</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;argument must be &gt; 0.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
        <span class="n">vm</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lamv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vm</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">lamn</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vl</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">dl</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">pbdv_seq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Dv(x) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of D_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives D_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="o">-</span><span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="n">dv</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">pbdv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dv</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">pbvv_seq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Vv(x) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of V_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives V_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="o">-</span><span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="n">dv</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">pbvv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dv</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">pbdn_seq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Dn(z) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of D_i(z), for i=0, ..., i=n.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives D_i&#39;(z), for i=0, ..., i=n.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be an integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">cpb</span><span class="p">,</span> <span class="n">cpd</span> <span class="o">=</span> <span class="n">specfun</span><span class="o">.</span><span class="n">cpbdn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cpb</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">cpd</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">ber_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ber.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ber</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bei_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function bei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bei</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ker_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ker.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ker</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kei_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function kei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kei</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">berp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function ber.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the derivative of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ber, berp</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">beip_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function bei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the derivative of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bei, beip</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kerp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function ker.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the derivative of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ker, kerp</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">keip_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function kei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the derivative of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kei, keip</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kelvin_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute nt zeros of all Kelvin functions.</span>

<span class="sd">    Returned in a length-8 tuple of arrays of length nt.  The tuple contains</span>
<span class="sd">    the arrays of zeros of (ber, bei, ker, kei, ber&#39;, bei&#39;, ker&#39;, kei&#39;).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
            <span class="n">specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">pro_cv_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Characteristic values for prolate spheroidal wave functions.</span>

<span class="sd">    Compute a sequence of characteristic values for the prolate</span>
<span class="sd">    spheroidal wave functions for mode m and n&#39;=m..n and spheroidal</span>
<span class="sd">    parameter c.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Modes must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">199</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Difference between n and m is too large.&quot;</span><span class="p">)</span>
    <span class="n">maxL</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">segv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="n">maxL</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">obl_cv_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Characteristic values for oblate spheroidal wave functions.</span>

<span class="sd">    Compute a sequence of characteristic values for the oblate</span>
<span class="sd">    spheroidal wave functions for mode m and n&#39;=m..n and spheroidal</span>
<span class="sd">    parameter c.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Modes must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">199</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Difference between n and m is too large.&quot;</span><span class="p">)</span>
    <span class="n">maxL</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">specfun</span><span class="o">.</span><span class="n">segv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="n">maxL</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The number of combinations of N things taken k at a time.</span>

<span class="sd">    This is often expressed as &quot;N choose k&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int, ndarray</span>
<span class="sd">        Number of things.</span>
<span class="sd">    k : int, ndarray</span>
<span class="sd">        Number of elements taken.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If `exact` is False, then floating point precision is used, otherwise</span>
<span class="sd">        exact long integer is computed.</span>
<span class="sd">    repetition : bool, optional</span>
<span class="sd">        If `repetition` is True, then the number of combinations with</span>
<span class="sd">        repetition is computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int, float, ndarray</span>
<span class="sd">        The total number of combinations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    binom : Binomial coefficient ufunc</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Array arguments accepted only for exact=False case.</span>
<span class="sd">    - If N &lt; 0, or k &lt; 0, then 0 is returned.</span>
<span class="sd">    - If k &gt; N and repetition=False, then 0 is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import comb</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([3, 4])</span>
<span class="sd">    &gt;&gt;&gt; n = np.array([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; comb(n, k, exact=False)</span>
<span class="sd">    array([ 120.,  210.])</span>
<span class="sd">    &gt;&gt;&gt; comb(10, 3, exact=True)</span>
<span class="sd">    120</span>
<span class="sd">    &gt;&gt;&gt; comb(10, 3, exact=True, repetition=True)</span>
<span class="sd">    220</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_comb_int</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">binom</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Permutations of N things taken k at a time, i.e., k-permutations of N.</span>

<span class="sd">    It&#39;s also known as &quot;partial permutations&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int, ndarray</span>
<span class="sd">        Number of things.</span>
<span class="sd">    k : int, ndarray</span>
<span class="sd">        Number of elements taken.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If `exact` is False, then floating point precision is used, otherwise</span>
<span class="sd">        exact long integer is computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int, ndarray</span>
<span class="sd">        The number of k-permutations of N.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Array arguments accepted only for exact=False case.</span>
<span class="sd">    - If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import perm</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([3, 4])</span>
<span class="sd">    &gt;&gt;&gt; n = np.array([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; perm(n, k)</span>
<span class="sd">    array([  720.,  5040.])</span>
<span class="sd">    &gt;&gt;&gt; perm(10, 3, exact=True)</span>
<span class="sd">    720</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">poch</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="c1"># https://stackoverflow.com/a/16327037</span>
<span class="k">def</span> <span class="nf">_range_prod</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Product of a range of numbers.</span>

<span class="sd">    Returns the product of</span>
<span class="sd">    lo * (lo+1) * (lo+2) * ... * (hi-2) * (hi-1) * hi</span>
<span class="sd">    = hi! / (lo-1)!</span>

<span class="sd">    Breaks into smaller products first for speed:</span>
<span class="sd">    _range_prod(2, 9) = ((2*3)*(4*5))*((6*7)*(8*9))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">+</span> <span class="n">lo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">*</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lo</span>
    <span class="k">return</span> <span class="n">lo</span> <span class="o">*</span> <span class="n">hi</span>


<div class="viewcode-block" id="factorial"><a class="viewcode-back" href="../../../api.html#stingray.deadtime.model.factorial">[docs]</a><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The factorial of a number or array of numbers.</span>

<span class="sd">    The factorial of non-negative integer `n` is the product of all</span>
<span class="sd">    positive integers less than or equal to `n`::</span>

<span class="sd">        n! = n * (n - 1) * (n - 2) * ... * 1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int or array_like of ints</span>
<span class="sd">        Input values.  If ``n &lt; 0``, the return value is 0.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If True, calculate the answer exactly using long integer arithmetic.</span>
<span class="sd">        If False, result is approximated in floating point rapidly using the</span>
<span class="sd">        `gamma` function.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nf : float or int or ndarray</span>
<span class="sd">        Factorial of `n`, as integer or float depending on `exact`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For arrays with ``exact=True``, the factorial is computed only once, for</span>
<span class="sd">    the largest input, with each other result computed in the process.</span>
<span class="sd">    The output dtype is increased to ``int64`` or ``object`` if necessary.</span>

<span class="sd">    With ``exact=False`` the factorial is approximated using the gamma</span>
<span class="sd">    function:</span>

<span class="sd">    .. math:: n! = \\Gamma(n+1)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorial</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; factorial(arr, exact=False)</span>
<span class="sd">    array([   6.,   24.,  120.])</span>
<span class="sd">    &gt;&gt;&gt; factorial(arr, exact=True)</span>
<span class="sd">    array([  6,  24, 120])</span>
<span class="sd">    &gt;&gt;&gt; factorial(5, exact=True)</span>
<span class="sd">    120</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">n</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">un</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

            <span class="c1"># Convert to object array of long ints if np.int_ can&#39;t handle size</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span>
            <span class="k">elif</span> <span class="n">un</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="nb">object</span>
            <span class="k">elif</span> <span class="n">un</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

            <span class="c1"># Handle invalid/trivial values</span>
            <span class="c1"># Ignore runtime warning when less operator used w/np.nan</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">un</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">un</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Calculate products of each range of numbers</span>
            <span class="k">if</span> <span class="n">un</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">un</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">==</span> <span class="n">un</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">un</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">val</span> <span class="o">*=</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">==</span> <span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">_factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<span class="k">def</span> <span class="nf">factorial2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Double factorial.</span>

<span class="sd">    This is the factorial with every second value skipped.  E.g., ``7!! = 7 * 5</span>
<span class="sd">    * 3 * 1``.  It can be approximated numerically as::</span>

<span class="sd">      n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd</span>
<span class="sd">          = 2**(n/2) * (n/2)!                           n even</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int or array_like</span>
<span class="sd">        Calculate ``n!!``.  Arrays are only supported with `exact` set</span>
<span class="sd">        to False.  If ``n &lt; 0``, the return value is 0.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        The result can be approximated rapidly using the gamma-formula</span>
<span class="sd">        above (default).  If `exact` is set to True, calculate the</span>
<span class="sd">        answer exactly using integer arithmetic.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nff : float or int</span>
<span class="sd">        Double factorial of `n`, as an int or a float depending on</span>
<span class="sd">        `exact`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorial2</span>
<span class="sd">    &gt;&gt;&gt; factorial2(7, exact=False)</span>
<span class="sd">    array(105.00000000000001)</span>
<span class="sd">    &gt;&gt;&gt; factorial2(7, exact=True)</span>
<span class="sd">    105</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">*=</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">oddn</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">cond1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">evenn</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">cond2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">nd2o</span> <span class="o">=</span> <span class="n">oddn</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">nd2e</span> <span class="o">=</span> <span class="n">evenn</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">place</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cond1</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nd2o</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">nd2o</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">place</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nd2e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">nd2e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">factorialk</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multifactorial of n of order k, n(!!...!).</span>

<span class="sd">    This is the multifactorial of n skipping k values.  For example,</span>

<span class="sd">      factorialk(17, 4) = 17!!!! = 17 * 13 * 9 * 5 * 1</span>

<span class="sd">    In particular, for any integer ``n``, we have</span>

<span class="sd">      factorialk(n, 1) = factorial(n)</span>

<span class="sd">      factorialk(n, 2) = factorial2(n)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Calculate multifactorial. If `n` &lt; 0, the return value is 0.</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of multifactorial.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If exact is set to True, calculate the answer exactly using</span>
<span class="sd">        integer arithmetic.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int</span>
<span class="sd">        Multifactorial of `n`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        Raises when exact is False</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorialk</span>
<span class="sd">    &gt;&gt;&gt; factorialk(5, 1, exact=True)</span>
<span class="sd">    120</span>
<span class="sd">    &gt;&gt;&gt; factorialk(5, 3, exact=True)</span>
<span class="sd">    10</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">*</span><span class="n">j</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">def</span> <span class="nf">zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Riemann or Hurwitz zeta function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like of float</span>
<span class="sd">        Input data, must be real</span>
<span class="sd">    q : array_like of float, optional</span>
<span class="sd">        Input data, must be real.  Defaults to Riemann zeta.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Output array for the computed values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Values of zeta(x).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The two-argument version is the Hurwitz zeta function</span>

<span class="sd">    .. math::</span>

<span class="sd">        \zeta(x, q) = \sum_{k=0}^{\infty} \frac{1}{(k + q)^x};</span>

<span class="sd">    see [dlmf]_ for details. The Riemann zeta function corresponds to</span>
<span class="sd">    the case when ``q = 1``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zetac</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [dlmf] NIST, Digital Library of Mathematical Functions,</span>
<span class="sd">        https://dlmf.nist.gov/25.11#i</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import zeta, polygamma, factorial</span>

<span class="sd">    Some specific values:</span>

<span class="sd">    &gt;&gt;&gt; zeta(2), np.pi**2/6</span>
<span class="sd">    (1.6449340668482266, 1.6449340668482264)</span>

<span class="sd">    &gt;&gt;&gt; zeta(4), np.pi**4/90</span>
<span class="sd">    (1.0823232337111381, 1.082323233711138)</span>

<span class="sd">    Relation to the `polygamma` function:</span>

<span class="sd">    &gt;&gt;&gt; m = 3</span>
<span class="sd">    &gt;&gt;&gt; x = 1.25</span>
<span class="sd">    &gt;&gt;&gt; polygamma(m, x)</span>
<span class="sd">    array(2.782144009188397)</span>
<span class="sd">    &gt;&gt;&gt; (-1)**(m+1) * factorial(m) * zeta(m+1, x)</span>
<span class="sd">    2.7821440091883969</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">_riemann_zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">_zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2021, Stingray Developers.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.5.3. &nbsp;
    Last built 06 Apr 2021. <br/>
  </p>
</footer>
  </body>
</html>